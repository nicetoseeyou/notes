volatile 特性
    volatile 修饰的变量在工作内存中进行写入操作后，会立即写回主内存，其他工作内存的这个变量失效，需要重新从主内存中读取，保证了程序的可见性
    volatile 为变量提供了内存屏障，防止指令的重排序，即 volatile 前的代码一定会在 volatile 前面执行，不在后面执行，保证了程序的有序性
    volatile 不能保证程序的原子性，例如 x=x+1 的操作，分为几个步骤，首先将 x 从主存读取到工作内存，然后将工作内存的 x 加 1，最后再将 x 写回主内存，这里的操作不具备原子性，因为可能存在工作内存的 x 加了 1，但是没有同步到主内存的中间状态.
    例如线程 A 将 x 从主存读取到工作内存，此时遇到 CPU 时间片轮转，执行权切换给线程 B
    线程 B 从主存中读取到 x 的值，并进行加 1 操作，但还没有写入到主内存
    CPU 执行权切换到 A，A 同样将 x 进行加 1，但由于线程 B 的值没有写入主内存，所以 x 的值还是 101，而不是 102

主内存与工作内存交互
    工作内存类似于 CPU 中的 cache，主内存类似于 RAM 的概念
    共享变量存放在主内存中，每个线程都可以访问
    每个线程都有其工作内存，线程访问某个变量时，是将该变量的值从主内存复制到自己的工作内存，工作内存只是存储变量的副本
    在更新某个变量时，首先更新的是在自己工作内存中的值，再刷新到主内存。
    所以如果没有任何的线程同步措施，其他线程对该变量的修改就会被这个线程覆盖

happen before原则
    happen before 原则是指 Java 内存模型中一些天然的有序性规则，不需要程序员的干预就可以保证有序
    在一个线程中，定义在前面的操作会比后面的操作先执行(JVM可能会进行指令重排序，这里的意思是线程执行结果与是否进行指令重排序的最终结果是一致的)
    锁机制: 一个锁的 unlock 操作必定先行发生于一个锁的 lock 操作
        如果一个锁处于锁定状态，那么必须解锁以后才能执行锁定操作
    violate 原则
        对一个被violate修饰的变量的写操作先行发生于对此变量的读操作
        即如果一个变量被violate修饰，当一个线程对这个变量进行写操作，另一个线程对其进行读操作，写操作会先于读操作
    线程启动原则
        线程的各种操作必定发生在start之后
    线程中断原则
        一个线程若收到中断信号，其之前必有interupt方法的调用
    线程执行原则
        线程中的各种操作先行发生于线程的结束
    先有生后有死
        一个对象的初始化先行发生于该对象的finalize方法

内存栅栏
    内存屏障保证
        在指令重排序时，内存屏障后的指令不会被重排到内存屏障的前面
        在指令重排序时，内存屏障前的指令不会被重排到内存屏障后面
        在执行到内存屏障时，前面的指令已经全部执行完毕
        在执行到内存屏障时，线程将工作内存的值写入到主内存
        在执行到内存屏障时，其他线程的工作内存中的值失效
    volatile为变量建立了内存屏障

简述为什么会出现锁机制
    在多线程同时访问一个共享变量的情况下，可能会导致数据不同步的情况，例如当一个线程A在读取变量时，另一个线程B修改了这个变量，那么线程A读取到的变量就是过期的数据，所以我们需要线程同步机制来确保同一时间只有一个线程更新或者读取变量，也就是锁机制

Java线程同步的方式有哪些？
    Synchronize
    显式锁

synchronized 和 volatile（可见性与禁止指令重排序）区别?
    synchronized 提供的是排他机制，当一个线程对变量进行读写时，其他线程只能阻塞等待，保证了原子性，可见性和有序性
    volatile 则通过防止指令重排序的方式使其他线程的工作内存失效，将线程缓存的值刷新到主内存，满足可见性和有序性。但在一个线程进行写操作时还可能会有其他线程进行访问，所以不具备原子性。

死锁是如何产生的以及四个必要条件？

简述ThreadLocal实现原理

Java中如何创建线程？

Java线程池使用有界队列实现时的饱和策略有哪些？

启动线程时，Start与run的区别是什么？
    start真正启动了线程
    run只是调用了对象的某个方法

介绍一下 AbstractQueuedSynchronizer ？

介绍一下 Condition ？

介绍一下 ReentrantLock ？

Java 中ReentrantLock的使用场景

Java 中 synchronized 与 Lock 的区别的使用场景

Java 中 synchronized 代码块的实现，以及 jdk1.6 对锁的优化？

Java 中的线程池实现有哪些？FixedThreadPool 底层使用的是什么任务队列？

Java 中的线程有几种状态？什么状态是阻塞状态？

怎么去看一个 Java 进程中有哪些线程处于阻塞状态的？
    通过jStack查看

ThreadLocal 的实现

Synchronized的实现（无锁队列等）

CAS底层实现原理

Java中的锁优化
